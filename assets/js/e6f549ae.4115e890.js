"use strict";(self.webpackChunkephemeris_notes=self.webpackChunkephemeris_notes||[]).push([[1196],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||r;return n?i.createElement(d,s(s({ref:t},p),{},{components:n})):i.createElement(d,s({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9730:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const r={title:"Scene Scale Tricks",tags:["TechnicalDetails","Rendering"]},s=void 0,o={unversionedId:"ImplementationDetails/Rendering/SceneScaleTricks",id:"ImplementationDetails/Rendering/SceneScaleTricks",title:"Scene Scale Tricks",description:"The Ephemeris simulation is completely double precision and uses SI units, 1unit = 1meter. However, this simulation must be displayed in the Unity scene. This is a problem - the Unity scene uses single precision coordinates for position, there is a fundamental part of the engine and there is no way to change this. As mentioned in Precision & Scale Unity recommends a maximum scene size of 50km (i.e. 50,000 units) at most. To fix this Ephemeris uses three tricks: scale, floating origin and offsetting.",source:"@site/docs/ImplementationDetails/Rendering/SceneScaleTricks.md",sourceDirName:"ImplementationDetails/Rendering",slug:"/ImplementationDetails/Rendering/SceneScaleTricks",permalink:"/EphemerisNotes/ImplementationDetails/Rendering/SceneScaleTricks",draft:!1,editUrl:"https://github.com/martindevans/EphemerisNotes/tree/master/docs/ImplementationDetails/Rendering/SceneScaleTricks.md",tags:[{label:"TechnicalDetails",permalink:"/EphemerisNotes/tags/technical-details"},{label:"Rendering",permalink:"/EphemerisNotes/tags/rendering"}],version:"current",frontMatter:{title:"Scene Scale Tricks",tags:["TechnicalDetails","Rendering"]},sidebar:"tutorialSidebar",previous:{title:"Line Grid Rendering",permalink:"/EphemerisNotes/ImplementationDetails/Rendering/Line Grid Rendering"},next:{title:"UnityPlugins",permalink:"/EphemerisNotes/ImplementationDetails/UnityPlugins"}},l={},c=[{value:"Scale",id:"scale",level:2},{value:"Floating Origin",id:"floating-origin",level:2},{value:"Offsetting",id:"offsetting",level:2}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The Ephemeris simulation is completely double precision and uses SI units, 1unit = 1meter. However, this simulation must be displayed in the Unity scene. This is a problem - the Unity scene uses single precision coordinates for position, there is a fundamental part of the engine and there is no way to change this. As mentioned in ",(0,a.kt)("a",{parentName:"p",href:"/EphemerisNotes/ImplementationDetails/PrecisionScale/"},"Precision & Scale")," Unity recommends a maximum scene size of 50km (i.e. 50,000 units) at most. To fix this Ephemeris uses three tricks: ",(0,a.kt)("strong",{parentName:"p"},"scale"),", ",(0,a.kt)("strong",{parentName:"p"},"floating origin")," and ",(0,a.kt)("strong",{parentName:"p"},"offsetting"),"."),(0,a.kt)("h2",{id:"scale"},"Scale"),(0,a.kt)("p",null,"The Earth is larger than 50km. To bring the planets back into a reasonable scale and distance from each other Ephemeris uses a scale of ",(0,a.kt)("strong",{parentName:"p"},"1 unit == 1000km"),". This scale makes individual planets reasonably small (Jupiter is only 139.8 units), but not ",(0,a.kt)("em",{parentName:"p"},"too")," small (Luna is 3.5 units). Planetary systems are within a reasonable range (e.g. Io is just 421.7 units from Jupiter)."),(0,a.kt)("p",null,"However, this does not solve the entire problem! The simulation is centered on the sun, so if that data was loaded into the scene (scaled appropriately) Jupiter would be placed at 741,070 units (5AU)! If the scenario has combat happening around Jupiter the precision would be terrible!"),(0,a.kt)("h2",{id:"floating-origin"},"Floating Origin"),(0,a.kt)("p",null,'To fix this problem Ephemeris also uses a floating origin. A specific body is chosen as the "origin" point and is locked into the scene at ',(0,a.kt)("inlineCode",{parentName:"p"},"(0,0,0)"),", all other bodies have the position of this body subtracted off them before they are put into the scene (all in double precision). Now if a scenario has combat around Jupiter then Jupiter can be chosen as the origin point in the scene, all moon and spaceships will be rendered in the scene relative to Jupiter."),(0,a.kt)("p",null,"Doing this is quite simple:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"double3 pos;\nif (entity == origin) {\n    pos = double3.zero;\n} else {\n    pos -= GetPositionFromSim(entity) - GetPositionFromSim(origin)\n}\n\ntransform.position = (float3)(pos / 1000000.0);\n")),(0,a.kt)("h2",{id:"offsetting"},"Offsetting"),(0,a.kt)("p",null,"We've now got planets rendered at reasonable scales and combat happening in the outer reaches of the solar system with stable rendering. There's one last thing to fix: if Jupiter is the origin then the sun is 741,070 units away, but it still needs to be visible! The limit here is the \"far plane\" of the camera - things beyond the far plane at not rendered at all."),(0,a.kt)("p",null,"To fix this position of the sun is offset to be just inside the far plane, to make it visible. The sun is then scaled down to make it appear the correct size."),(0,a.kt)("p",null,"First we need to calculate the vector from the sun to the camera and move the sun:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"// Get the vector from the sun to the camera\nvar v = camera.Position - position;\nvar worldDistance = math.length(v);\n\n// Normalize `v`\nv /= worldDistance;\n\n// Do nothing if it's close enough\nif (worldDistance < camera.FarClip) {\n    return;\n}\n\n// Calculate how much the position needs to be offset to being it back to the far clip plane\noffset = v * (worldDistance - camera.FarClip);\n\n// Move the sun by that offset\nnew_position = position + offset;\n")),(0,a.kt)("p",null,"Now the sun will be far too big! To scale it down:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'// Calculate the new distance from the camera to the sun\nvar actualDistance = math.distance(new_position, camera.Position);\n\n// Scale down by the ratio between the actual distance and the "correct" distance\nscale = (float)(actualDistance / worldDistance);\n')))}m.isMDXComponent=!0}}]);