"use strict";(self.webpackChunkephemeris_notes=self.webpackChunkephemeris_notes||[]).push([[7219],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(a),h=r,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||s;return a?n.createElement(d,i(i({ref:t},c),{},{components:a})):n.createElement(d,i({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4823:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const s={title:"Generating Meshes",tags:["TechnicalDetails"]},i=void 0,o={unversionedId:"ImplementationDetails/ProceduralGeneration/GeneratingMeshes",id:"ImplementationDetails/ProceduralGeneration/GeneratingMeshes",title:"Generating Meshes",description:"Unity has the MeshDataArray system for procedurally generating an array of meshes in a job compatible way.",source:"@site/docs/ImplementationDetails/ProceduralGeneration/GeneratingMeshes.md",sourceDirName:"ImplementationDetails/ProceduralGeneration",slug:"/ImplementationDetails/ProceduralGeneration/GeneratingMeshes",permalink:"/EphemerisNotes/ImplementationDetails/ProceduralGeneration/GeneratingMeshes",draft:!1,editUrl:"https://github.com/martindevans/EphemerisNotes/tree/master/docs/ImplementationDetails/ProceduralGeneration/GeneratingMeshes.md",tags:[{label:"TechnicalDetails",permalink:"/EphemerisNotes/tags/technical-details"}],version:"current",frontMatter:{title:"Generating Meshes",tags:["TechnicalDetails"]},sidebar:"tutorialSidebar",previous:{title:"Editor Procedural Generation",permalink:"/EphemerisNotes/ImplementationDetails/ProceduralGeneration/EditorProceduralGeneration"},next:{title:"CPU Line Rendering",permalink:"/EphemerisNotes/ImplementationDetails/Rendering/CPULines"}},l={},p=[{value:"Generating Data",id:"generating-data",level:2}],c={toc:p};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unity has the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/ScriptReference/Mesh.MeshDataArray.html"},(0,r.kt)("inlineCode",{parentName:"a"},"MeshDataArray"))," system for procedurally generating an array of meshes in a job compatible way."),(0,r.kt)("p",null,"To create new meshes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var data = Mesh.AllocateWritableMeshData(number_of_meshes);\n// generate data, possibly in a job\nMesh.ApplyAndDisposeWritableMeshData(array_of_meshes);\n")),(0,r.kt)("p",null,"To read from existing meshes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var data = Mesh.AcquireReadOnlyMeshData(a_mesh)\n")),(0,r.kt)("h2",{id:"generating-data"},"Generating Data"),(0,r.kt)("p",null,"Once you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"MeshData")," (one element from a ",(0,r.kt)("inlineCode",{parentName:"p"},"MeshDataArray"),") you need to put some data into it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"private static void ApplyToMeshData(Mesh.MeshData mesh, List<Vector3> vertices, List<int> indices)\n{\n")),(0,r.kt)("p",null,"A mesh may have submeshes. In this example we'll just have one submesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// One sub-mesh with all the indices.\nmesh.subMeshCount = 1;\n")),(0,r.kt)("p",null,"The exact elements of each vertex need to be setup first. Here we're going to set ",(0,r.kt)("strong",{parentName:"p"},"2")," elements per vertex, a position (",(0,r.kt)("inlineCode",{parentName:"p"},"float x 3"),") and a texture coordinate (",(0,r.kt)("inlineCode",{parentName:"p"},"float x 2"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var attrs = new NativeArray<VertexAttributeDescriptor>(2, Allocator.Temp)\n{\n    [0] = new VertexAttributeDescriptor(VertexAttribute.Position, VertexAttributeFormat.Float32, 3, 0),\n    [1] = new VertexAttributeDescriptor(VertexAttribute.TexCoord0, VertexAttributeFormat.Float32, 2, 1)\n};\nmesh.SetVertexBufferParams(vertices.Count, attrs);\n")),(0,r.kt)("p",null,"Now we're going to set the position data (texture coordinate data would be the same, so we'll skip it in this example):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Set position\nvar vp = mesh.GetVertexData<Vector3>(0); // Use the same stream index as above\nvp.CopyFrom(vertices.ToArray());\n")),(0,r.kt)("p",null,"Now we need to choose if the index buffer will use 16 bir or 32 bit indices. It's better to use 16 bit if possible (consumes less memory). It's easy to automatically use the smaller format when possible with this boilerplate:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"if (indices.Any(i => i > ushort.MaxValue))\n{\n    mesh.SetIndexBufferParams(indices.Count, IndexFormat.UInt32);\n    mesh.GetIndexData<int>().CopyFrom(indices.ToArray());\n}\nelse\n{\n    mesh.SetIndexBufferParams(indices.Count, IndexFormat.UInt16);\n    mesh.GetIndexData<ushort>().CopyFrom(indices.Select(a => (ushort)a).ToArray());\n}\n")),(0,r.kt)("p",null,"Finally because all submeshes are sharing the same index and vertex buffer we need to tell it where each sub-mesh is in the index buffer. That's easy with just one mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"mesh.SetSubMesh(index: 0, new SubMeshDescriptor(indexStart: 0, indexCount: indices.Count));\n")),(0,r.kt)("p",null,"That's it! We can now apply this data to a mesh:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var mesh = new Mesh();\nMesh.ApplyAndDisposeWritableMeshData(data, mesh);\nmesh.bounds = CalculateSomeBounds();\nreturn mesh;\n")))}m.isMDXComponent=!0}}]);