"use strict";(self.webpackChunkephemeris_notes=self.webpackChunkephemeris_notes||[]).push([[6577],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(n),u=r,d=c["".concat(s,".").concat(u)]||c[u]||h[u]||i;return n?a.createElement(d,l(l({ref:t},m),{},{components:n})):a.createElement(d,l({ref:t},m))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},809:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={tags:["TechnicalDetails","Rendering","GPU","Shaders"]},l=void 0,o={unversionedId:"ImplementationDetails/Rendering/GPU Lines",id:"ImplementationDetails/Rendering/GPU Lines",title:"GPU Lines",description:"Ephemeris needs to draw a lot of lines to show orbital paths. In fact most of the important information in the game is communicated entirely with lines and UI elements!",source:"@site/docs/ImplementationDetails/Rendering/GPU Lines.md",sourceDirName:"ImplementationDetails/Rendering",slug:"/ImplementationDetails/Rendering/GPU Lines",permalink:"/EphemerisNotes/ImplementationDetails/Rendering/GPU Lines",draft:!1,editUrl:"https://github.com/martindevans/EphemerisNotes/tree/master/docs/ImplementationDetails/Rendering/GPU Lines.md",tags:[{label:"TechnicalDetails",permalink:"/EphemerisNotes/tags/technical-details"},{label:"Rendering",permalink:"/EphemerisNotes/tags/rendering"},{label:"GPU",permalink:"/EphemerisNotes/tags/gpu"},{label:"Shaders",permalink:"/EphemerisNotes/tags/shaders"}],version:"current",frontMatter:{tags:["TechnicalDetails","Rendering","GPU","Shaders"]},sidebar:"tutorialSidebar",previous:{title:"CarmackStarRendering",permalink:"/EphemerisNotes/ImplementationDetails/Rendering/CarmackStarRendering"},next:{title:"UnityPlugins",permalink:"/EphemerisNotes/ImplementationDetails/UnityPlugins"}},s={},p=[{value:"The Goal",id:"the-goal",level:2},{value:"Research",id:"research",level:2},{value:"Approach 1: Pure GPU",id:"approach-1-pure-gpu",level:2},{value:"Approach 2: No Compute",id:"approach-2-no-compute",level:2},{value:"Final?",id:"final",level:2}],m={toc:p};function h(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Ephemeris needs to draw a lot of lines to show orbital paths. In fact most of the important information in the game is communicated entirely with lines and UI elements!"),(0,r.kt)("p",null,"Orbital paths have several requirements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'- They have a **lot** of points (e.g. 2+ weeks of orbital movement)\n- Position data between points should be interpolated non-linearly (specially when zooming in)\n- Scale of positions is literally astronomical (double precision may be required).\n    - The line may even go beyond the camera far plane and should still be visible!\n- Extra information should be able to be shown (e.g. engine burn start/end times).\n- UI elements (e.g. markers of special events) should be able to "interact" visually with lines.\n- Line should be constant screen size so that it is visible at vast distances.\n')),(0,r.kt)("h2",{id:"the-goal"},"The Goal"),(0,r.kt)("p",null,"Here is an example image, showing everything required."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Note the border around the marker sphere where the line disappears."),(0,r.kt)("li",{parentName:"ul"},"Red sections indicate engine burns, these should be pixel perfect."),(0,r.kt)("li",{parentName:"ul"},"Everything in this image could be beyond the camera far plane!")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(8454).Z,width:"925",height:"642"})),(0,r.kt)("h2",{id:"research"},"Research"),(0,r.kt)("p",null,"While working on line rendering I came across several other approaches for rendering lines. Here's an unordered list:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/Manual/class-LineRenderer.html"},"Unity LineRenderer"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Does not handle huge scale"),(0,r.kt)("li",{parentName:"ul"},"Cannot render with constant screen width"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/johannesugb/VolumetricLinesUnity"},"Volumetric Lines - Unity Asset"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Make sure to use the ",(0,r.kt)("inlineCode",{parentName:"li"},"universal_render_pipeline")," branch!"),(0,r.kt)("li",{parentName:"ul"},"Uses shader tricks to render the line, maybe be useful down later with other line rendering techniques",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://web.archive.org/web/20150930205745/http://sebastien.hillaire.free.fr/index.php?option=com_content&view=article&id=54&Itemid=56"},"https://web.archive.org/web/20150930205745/http://sebastien.hillaire.free.fr/index.php?option=com_content&view=article&id=54&Itemid=56")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://web.archive.org/web/20111202022753/http://sebastien.hillaire.free.fr/index.php?option=com_content&view=article&id=57&Itemid=74"},"https://web.archive.org/web/20111202022753/http://sebastien.hillaire.free.fr/index.php?option=com_content&view=article&id=57&Itemid=74")))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://assetstore.unity.com/packages/tools/particles-effects/shapes-173167"},"Shapes Asset"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Great asset, highly recommended!"),(0,r.kt)("li",{parentName:"ul"},"Does not handle huge scale."),(0,r.kt)("li",{parentName:"ul"},"Recomputing line mesh when position changes seems to be expensive (not jobified)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShapesMeshGen.GenPolylineMesh")," helper generates mesh, potentially this could be used directly to generate the mesh from inside a parallel ",(0,r.kt)("inlineCode",{parentName:"li"},"Task"),".")))),(0,r.kt)("h2",{id:"approach-1-pure-gpu"},"Approach 1: Pure GPU"),(0,r.kt)("p",null,'My first approach to solving this problem was intended as a "pure GPU" solution:'),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Dump the orbital position data straight from the sim into a ",(0,r.kt)("inlineCode",{parentName:"li"},"ComputeBuffer")),(0,r.kt)("li",{parentName:"ol"},"Run a compute shader to create vertices along the line - adding extra vertices to interpolate the data."),(0,r.kt)("li",{parentName:"ol"},"Draw line-strip vertices"),(0,r.kt)("li",{parentName:"ol"},"In geometry shader, emit new vertices to make the line wider (constant screen size).")),(0,r.kt)("p",null,"This approach has a few problems. First of all, I'm not very familiar with compute shaders, and while I am learning more about using them for Ephemeris this would be tricky to implement (for me). Secondly, and maybe more importantly, geometry shaders are slow:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://gamedev.stackexchange.com/questions/187584/has-the-geometry-shader-been-abandonded"},"https://gamedev.stackexchange.com/questions/187584/has-the-geometry-shader-been-abandonded")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://www.joshbarczak.com/blog/?p=667"},"http://www.joshbarczak.com/blog/?p=667"))),(0,r.kt)("p",null,"Maybe they're not slow enough to be a problem, but I don't want to put in all the effort to implement this approach only to discover it's not fast enough to actually use!"),(0,r.kt)("p",null,"While researching this technique, I researched some geometry shader related things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/chenjd-xyz/using-the-geometry-shader-in-unity-to-generate-countless-of-grass-on-gpu-4ca6d78b3de6"},"Geometry shader grass")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://gamedevbill.com/unity-vertex-shader-and-geometry-shader-tutorial/"},"General geometry shader tutorial")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://forum.unity.com/threads/geometry-shader-with-meshtopology-linestrip.684643/"},"LineStrip+GeometryShader"))),(0,r.kt)("h2",{id:"approach-2-no-compute"},"Approach 2: No Compute"),(0,r.kt)("p",null,"The problems with the previous approach were compute shaders (i'm not very familiar with them) and geometry shaders (should be avoided because they're slow). My second approach tries to solve both of these problems."),(0,r.kt)("p",null,"The first step happens in the editor - procedurally generating lines with fixed numbers of vertices and storing these as assets. The lines are tubes, with 4 vertices around each point, this will be used later to give the line constant on screen size."),(0,r.kt)("p",null,"My approach to procedurally generating the lines is to use a ",(0,r.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/Manual/ScriptedImporters.html"},(0,r.kt)("inlineCode",{parentName:"a"},"ScriptedImporter")),". Procedural generation parameters are stored in a file with a unique file extension (",(0,r.kt)("inlineCode",{parentName:"p"},".procline"),") and then a scripted importer can pickup that file and run the generation in-editor. See more details ",(0,r.kt)("a",{parentName:"p",href:"/EphemerisNotes/ImplementationDetails/ProceduralGeneration/EditorProceduralGeneration"},"here"),"."),(0,r.kt)("p",null,"todo:write up the rest"),(0,r.kt)("p",null,"Investigate more:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://mattdesl.svbtle.com/drawing-lines-is-hard"},"https://mattdesl.svbtle.com/drawing-lines-is-hard"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Send mesh to GPU"),(0,r.kt)("li",{parentName:"ul"},"Push to width in vertex shader (constant screen width)")))),(0,r.kt)("h2",{id:"final"},"Final?"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Generate line mesh",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Scripted Importer to generate mesh (",(0,r.kt)("inlineCode",{parentName:"li"},"MeshData")," API)"))),(0,r.kt)("li",{parentName:"ol"},"Pass position/timestamp in computer buffer",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Position/timestamp in float64 (straight from sim)"))),(0,r.kt)("li",{parentName:"ol"},"In vertex shader",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Read position"),(0,r.kt)("li",{parentName:"ul"},"Convert to smaller scale (and then convert into single precision)"),(0,r.kt)("li",{parentName:"ul"},"Clamp to near/far plane",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.vertexfragment.com/ramblings/unity-prevent-object-culling/"},"https://www.vertexfragment.com/ramblings/unity-prevent-object-culling/")))),(0,r.kt)("li",{parentName:"ul"},"Generate tangent frames from change in position"),(0,r.kt)("li",{parentName:"ul"},"Apply offset from mesh vertex to position"))),(0,r.kt)("li",{parentName:"ol"},"In pixel shader",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"clip out pixels with timestep < now"),(0,r.kt)("li",{parentName:"ul"},"clip out vertices which have no timestamp data at all (past end of time)")))))}h.isMDXComponent=!0},8454:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Unity_2023-03-17_16-56-31-500cefa8f90128d2876b7f56a904a42f.png"}}]);